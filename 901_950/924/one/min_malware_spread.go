package one

// 特别注意点: 如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。
//			 那么如果超过两个节点关联都被感染，删除一个不能解决问题，所以需要找只有1个感染节点的

// [[1,1,0,0,0],[1,1,1,1,0],[0,1,1,0,0],[0,1,0,1,0],[0,0,0,1,1]]
// [0,2,3]

const (
	r = 1 << iota // 感染节点
	p             // 使用中
	u             // 使用过
)

func MinMalwareSpread(graph [][]int, initial []int) int {
	nums := make(map[int]int, len(graph))
	nodes := make(map[int]byte, len(initial))
	dn := make(map[int]byte, len(initial)) // 被连接的感染点
	// 感染节点
	for _, node := range initial {
		nodes[node] = r
	}
	var dfs func(int, int) int
	dfs = func(on, node int) int {
		// 处理过了
		if nodes[node]&u > 0 {
			dn[on] = 1
			return 0
		}
		// 正在处理中
		if nodes[node]&p > 0 {
			return 0
		}
		nodes[node] |= p
		total := 1
		for i := range graph {
			if graph[node][i] == 1 && node != i {
				// 跳过感染节点
				if nodes[i]&r > 0 {
					if on != i {
						dn[on] = 1
						dn[i] = 1
						total = 0
						break
					}
					// 循环依赖丢弃即可
					continue
				}
				total += dfs(node, i)
				if dn[on] == 1 {
					total = 0
					break
				}
			}
		}
		nums[node] = total
		nodes[node] |= u
		return total
	}
	for _, node := range initial {
		if dn[node] == 0 {
			dfs(node, node)
		}
	}
	ans := -1
	for _, node := range initial {
		if ans == -1 || nums[node] > nums[ans] || (nums[node] == nums[ans] && node < ans) {
			ans = node
		}
	}
	return ans
}
